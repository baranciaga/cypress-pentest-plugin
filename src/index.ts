import fs from 'fs'
import process from 'process'
import os from 'os'
import fetch from 'node-fetch'
import {spawn} from "node:child_process"
import * as path from 'path';
import {sendPOSTRequest} from "./utils/requests";
import {Interception} from "cypress/types/net-stubbing";
// declare variables for http status codes
const HTTP_SUCCESS = Array.from({ length: 100 }, (_, index) => index + 200);
const HTTP_REDIRECT = Array.from({ length: 100 }, (_, index) => index + 300);
const HTTP_ERROR = Array.from({ length: 100 }, (_, index) => index + 400);
const HTTP_SERVER_ERROR = Array.from({ length: 100 }, (_, index) => index + 500);
// declare variables for paths
const logsPath = path.join(process.cwd(), 'logs', 'cypress.log');
const payloadPath = path.join(process.cwd(), 'lists', 'sqli.txt');
const nosqlPayloadsPath = path.join(process.cwd(), 'lists', 'nosql');
const secondOrderLogs = path.join(process.cwd(), 'logs', 'test.log');

// const Cypress = require('cypress'); // might be false
/**
 * function that checks a specific endpoint for sql injection.
 * @module cypress-pentest-baseline
 * @param request: Is the intercepted request
 * @param httpMethod: HTTP method, e.g. POST, GET etc.
 * @param endpoint: The endpoint to test
 * @param postParams: The parameters used in the request
 */
// TODO: add correct return type || Only one payload parameter per request?
// TODO: Implement enum for sql injection type: boolean, union, nosql, etc.
export async function checkEndpoint(request: any, httpMethod: any, endpoint: any, postParams: any)
{
    const req = request.request
    const newRequestString = JSON.stringify(req, null, 2)
    // Logging since console.log does not work
    const newLog = `-------------------------------------\n Intercepted Request: ${newRequestString}\n`
    fs.appendFileSync(logsPath, newLog)
    let payloads: string[] = []
    if (fs.existsSync(payloadPath)) {
        const fileContent = fs.readFileSync(payloadPath, 'utf-8')
        payloads = fileContent.split('\n')
    } else {
        console.error('File does not exist:', logsPath)
        fs.appendFileSync(logsPath, `Error. Cannot find payloads list: ${payloadPath}`)
    }
    // create the requests with the post Parameters declared in the test file
    fs.appendFileSync(logsPath, `Method: ${httpMethod}\n`)
    fs.appendFileSync(logsPath, `Endpoint: ${endpoint}\n`)
    for (let i = 0; i < payloads.length; i++) {
        // request parameters provided by the function call, e.g. username, password
        const reqParameters: object = {}
        postParams.forEach(function (param: string) {
            reqParameters[param] = payloads[i]
        })
        // assign the request parameters to the request body and header
        // TODO: outsource
        req.body = reqParameters
        // req.body['username'] = payloads[i]
        const body = JSON.stringify(req.body)
        const header = JSON.stringify(req.headers)
        req.headers['content-length'] = body.length.toString()
        // send the request and wait for the response
        const response = await fetch(endpoint, {
            method: httpMethod,
            body: '' + body,
            headers: req.headers
        })
        const data = await response.text()
        // log and print the response for debugging purposes
        if (HTTP_SUCCESS.includes(response.status)) {
            fs.appendFileSync(logsPath, `Loop iteration: ${i}\n`)
            fs.appendFileSync(logsPath, `Header of Request: ${header}\n`)
            fs.appendFileSync(logsPath, `Body of Request: ${body}\n`)
            fs.appendFileSync(logsPath, `Content length of new body: ${body.length.toString()}\n`)
            fs.appendFileSync(logsPath, `Response data: ${JSON.stringify(data, null, 2)}\n`)
            fs.appendFileSync(logsPath, `Response Status: ${JSON.stringify(response.status)}\n`)
            fs.appendFileSync(logsPath, `Response Text: ${JSON.stringify(response.statusText)}\n`)
            fs.appendFileSync(logsPath, '------------------------------------------------------\n')

        }
    }
    return null
}
/**
 * function that provides a sqlmap child process inside cypress. Parameters are inside a json object bc of cypress.
 * @param route: url to test
 * @param args: array of arguments for sqlmap, e.g. --dbs --level=3 --risk=3 --batch
 */
export async function sqlMap ({ route, args }) {
    return await new Promise((resolve, reject) => {
        const homeDir = os.homedir()
        // clone the repo to the home directory before calling this function - otherwise it will fail
        const filePath = path.join(homeDir, 'sqlmap-dev', 'sqlmap.py')
        fs.appendFileSync(logsPath, '...starting SQL map...\n')
        if (args === '') {
            args = ['-h']
        }
        try {
            fs.appendFileSync(logsPath, `python3 ${filePath}  -u ${route}`)
            const child = spawn(`python3 ${filePath}  -u ${route}`, args, { shell: true }).on('error', function (err) { throw err })
            child.stdout.on('data', (data) => {
                fs.appendFileSync(logsPath, `sqlmap-data: ${data}\n`)
                // child.kill() // not sure if these are necessary
                // resolve(false)
            })
            child.on('exit', (code, signal) => {
                fs.appendFileSync(logsPath, `Child process exited with code ${code} and signal ${signal}\n`)
                child.kill()
                resolve(false)
            })
        } catch (e) {
            fs.appendFileSync(logsPath, `Error Message from Spawn: ${e}\n`)
            reject(e)
        }
    })
}

/**
 * spawnShell - DEPRECATED: use function sqlMap instead.
 * @param command: shell command to execute
 * @param args: arguments for the shell command
 */
export async function spawnShell ({ command, args }) {
    return await new Promise((resolve, reject) => {
        console.log(args)
        try {
            const child = spawn(command, args, { shell: true }).on('error', function (err) { throw err })
            child.stdout.on('data', (data) => {
                fs.appendFileSync(process.cwd() + '\\logs\\cypress.log', `DATA EVENT LISTENER ${data}\n`)
                child.kill()
                resolve(false)
            })
            child.on('exit', (code, signal) => {
                fs.appendFileSync(process.cwd() + '\\logs\\cypress.log', `Child process exited with code ${code} and signal ${signal}\n`)
                child.kill()
                resolve(false)
            })
        } catch (e) {
            fs.appendFileSync(process.cwd() + '\\logs\\cypress.log', `Error Message from Spawn: ${e}\n`)
            reject(e)
        }
    })
}

/**
 * Tests SQLi using the header of a request
 * @param request: Intercepted request
 * @param headers:
 */
// TODO: Implement payload list for header sql injection
export async function headerSQLi ({ request, headers }) {
    const endpoint = 'http://localhost:3000/rest/user/login'
    const req = request.request
    const body = JSON.stringify(req.body)
    for (let i = 0; i < headers.length; i++) {
        req.headers[`${headers[i]}`] = '\' or 1=1--'
    }
    // req.headers.cookie = 'this is a test'
    // req.headers['x-forwarded-for'] = '123.123.123.123'
    const reqJson = JSON.stringify(req, null, 2)
    const logMessage = `\n Request with new cookie: ${reqJson}\n`
    const pathToLog = process.cwd() + '\\logs\\sqli.log'
    fs.appendFileSync(pathToLog, logMessage)
    const response = await fetch(endpoint, {
        method: 'POST',
        body: '' + body,
        headers: req.headers
    })
    const data = await response.text()
    fs.appendFileSync(pathToLog, `Header of Request: ${JSON.stringify(req.headers)}\n`)
    fs.appendFileSync(pathToLog, `Response data: ${JSON.stringify(data)}\n`)
    fs.appendFileSync(pathToLog, `Response Status: ${JSON.stringify(response.status)}\n`)
    return null
}

/**
 * Tests for second order SQLi
 * @param request: the intercepted request
 */
export async function secondOrderAttack (request: any) {
    fs.appendFileSync(secondOrderLogs, process.cwd())

    const endpoint = 'http://localhost:3000/api/Users/'
    const pathToLog = process.cwd() + '\\logs\\sqli.log'
    fs.appendFileSync(pathToLog, '++++++++++++++++++++++++++ Second Order SQL Injection ++++++++++++++++++++++++++\n')
    const req = request.request // request-structure depending on api?
    const reqStringified = JSON.stringify(req, null, 2)
    const loggedMessage = `\n ++++Intercepted Request: ++++\n ${reqStringified}\n`
    fs.appendFileSync(pathToLog, loggedMessage)
    // req.body.email = 'admin@juice-sh.op\'--'
    req.request.body.email = 'baran_advisori@test.com'
    const body = JSON.stringify(req.request.body)
    const response = await fetch(endpoint, {
        method: 'POST',
        body: '' + body,
        headers: req.headers
    })
    const reqJSON = JSON.stringify(req, null, 2)
    const logMessage = `\n ++++Request with new username: ++++\n${reqJSON}\n`
    fs.appendFileSync(pathToLog, logMessage)
    const data = await response.text()
    fs.appendFileSync(pathToLog, `Response data: ${JSON.stringify(data, null, 2)}\n`)
    fs.appendFileSync(pathToLog, `Response Status: ${JSON.stringify(response.status)}\n`)
    return null
}

/**
 * Checks endpoint for noSQL-injection
 * @param request: the intercepted request
 */
export async function noSQLiCheck (request) {
    const newRequest = request
    let payloads = []
    if (fs.existsSync(nosqlPayloadsPath)) {
        const fileContent = fs.readFileSync(nosqlPayloadsPath, 'utf-8')
        payloads = fileContent.split('\n')
        // fs.appendFileSync(path, `Payloads:\n ${payloads}`)
    } else {
        console.error('File does not exist:', logsPath)
        fs.appendFileSync(logsPath, `Error! File does not exist: ${payloadPath}`)
    }
    for (let i = 0; i < payloads.length; i++) {
        newRequest.request.body = {
            email: payloads[i],
            password: payloads[i]
        }
        const body = JSON.stringify(newRequest.request.body)
        const header = JSON.stringify(newRequest.request.headers)
        newRequest.request.headers['content-length'] = body.length.toString()
        const response = await fetch('endpoint', {
            method: 'POST',
            body: '' + body,
            headers: newRequest.request.headers
        })
        const res = await response.text()
        if (HTTP_SUCCESS.includes(response.status)) {
            // Logging for debugging purposes.
            fs.appendFileSync(logsPath, `Loop iteration: ${i}\n`)
            fs.appendFileSync(logsPath, `Header of Request: ${header}\n`)
            fs.appendFileSync(logsPath, `Body of Request: ${body}\n`)
            fs.appendFileSync(logsPath, `Content length of new body: ${body.length.toString()}\n`)
            fs.appendFileSync(logsPath, `Response data: ${JSON.stringify(res, null, 2)}\n`)
            fs.appendFileSync(logsPath, `Response Status: ${JSON.stringify(response.status)}\n`)
            fs.appendFileSync(logsPath, `Response Text: ${JSON.stringify(response.statusText)}\n`)
            fs.appendFileSync(logsPath, '------------------------------------------------------\n')
        }
    }
    return null
}

/**
 * Function that analyzes the flags of the HTTP header regarding security
 * @param request
 */
export async function checkHeaderFlags(request){

    return null
}

/**
 * function that conducts a crlf injection by inserting several newline characters into the request
 * @param request: the intercepted request
 */
export async function crlfInjection(request){

    return null
}

/**
 * function that checks a component for XSS vulnerabilities
 * @param request: the intercepted request that is used to alter the input
 */
// TODO: find way to check DOM for alert
export async function reflectedXSS(request: Interception){
    const dir = path.join(process.cwd(), 'lists', 'xss');
    const log = path.join(process.cwd(), 'logs', 'xss.log');
    const req = request.request
    let payloads: string[] = []
    if (fs.existsSync(dir)) {
        const fileContent = fs.readFileSync(dir, 'utf-8')
        payloads = fileContent.split('\n')
    } else {
        console.error('File does not exist:', logsPath)
        fs.appendFileSync(logsPath, `Error. Cannot find payloads list: ${payloadPath}`)
    }
    const method = req.method; // does this work?
    const endpoint = req.url;
    fs.appendFileSync(log, `Request Method: ${method}\n`)
    fs.appendFileSync(log, `Loop Endpoint: ${endpoint}\n`)
    if (method === 'GET') {
        return null;
    } else if (method === 'POST') {
        return null;
    }
    return null
}
export async function storedXSS(request: Interception) {

}