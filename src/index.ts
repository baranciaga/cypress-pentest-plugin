import Chainable = Cypress.Chainable;

import fs from 'fs';
import process from 'process';
import os from 'os';
import fetch from 'node-fetch'
import {spawn} from "node:child_process";
const path = process.cwd() + '\\logs\\cypress.log'
const payloadPath = process.cwd() + '\\lists\\sqli.txt'
const nosqlPath = process.cwd() + '\\lists\\nosql'
const testPath = process.cwd() + '\\logs\\test.log'

/*
export const checkEndpointCommand = () => {
    Cypress.Commands.add('checkEndpoint', (request, method, endpoint, postParams) => {
        return cy.task('checkEndpoint', { request, method, endpoint, postParams })
    })
}
 */


// const Cypress = require('cypress'); // might be false
/**
 * @module cypress-pentest-baseline
 * @param request: The intercepted request
 * @param method: HTTP method
 * @param endpoint: The endpoint to test
 * @param postParams: The parameters used in the request
 */
// TODO: add correct return type || Only one payload parameter per request?
export async function checkEndpoint(request: any, method: any, endpoint: any, postParams: any)
{
    const req = request.request
    const newRequestString = JSON.stringify(req, null, 2)
    const newLog = `+++plugin+++\n Intercepted Request: ${newRequestString}\n`
    // Logging since console.log does not work
    fs.appendFileSync(path, newLog)
    let payloads: string[] = []
    if (fs.existsSync(payloadPath)) {
        const fileContent = fs.readFileSync(payloadPath, 'utf-8')
        payloads = fileContent.split('\n')
    } else {
        console.error('File does not exist:', path)
        fs.appendFileSync(path, `Error. Cannot find payloads list: ${payloadPath}`)
    }
    // create the requests with the post Parameters declared in the test file
    fs.appendFileSync(path, `Method: ${method}\n`)
    fs.appendFileSync(path, `Endpoint: ${endpoint}\n`)
    for (let i = 0; i < payloads.length; i++) {
        const reqParameters: object = {} // changed this from const body = {}
        postParams.forEach(function (param: string) {
            reqParameters[param] = payloads[i]
        })

        req.body = reqParameters
        // req.body['username'] = payloads[i]
        const body = JSON.stringify(req.body)
        const header = JSON.stringify(req.headers)
        req.headers['content-length'] = body.length.toString()
        // send the request and wait for the response
        const response = await fetch(endpoint, {
            method: method,
            body: '' + body,
            headers: req.headers
        })
        const data = await response.text()
        if (response.status === 200) {
            fs.appendFileSync(path, `Loop iteration: ${i}\n`)
            fs.appendFileSync(path, `Header of Request: ${header}\n`)
            fs.appendFileSync(path, `Body of Request: ${body}\n`)
            fs.appendFileSync(path, `Content length of new body: ${body.length.toString()}\n`)
            fs.appendFileSync(path, `Response data: ${JSON.stringify(data, null, 2)}\n`)
            fs.appendFileSync(path, `Response Status: ${JSON.stringify(response.status)}\n`)
            fs.appendFileSync(path, `Response Text: ${JSON.stringify(response.statusText)}\n`)
            fs.appendFileSync(path, '------------------------------------------------------\n')
        }
    }
    return null
}
export async function SQLInject ({ route, args }) {
    return await new Promise((resolve, reject) => {
        const homeDir = os.homedir()
        const filename = 'sqlmap-dev\\sqlmap.py'
        const filePath = `${homeDir}\\${filename}`
        fs.appendFileSync(path, '...starting SQL map...\n')
        if (args === '') {
            args = ['-h']
        }
        try {
            fs.appendFileSync(path, `python3 ${filePath}  -u ${route}`)
            const child = spawn(`python3 ${filePath}  -u ${route}`, args, { shell: true }).on('error', function (err) { throw err })
            child.stdout.on('data', (data) => {
                fs.appendFileSync(path, `sqlmap-data: ${data}\n`)
                // child.kill() // not sure if these are necessary
                // resolve(false)
            })
            child.on('exit', (code, signal) => {
                fs.appendFileSync(path, `Child process exited with code ${code} and signal ${signal}\n`)
                child.kill()
                resolve(false)
            })
        } catch (e) {
            fs.appendFileSync(path, `Error Message from Spawn: ${e}\n`)
            reject(e)
        }
    })
}
export function test(x1,x2){
    fs.appendFileSync(path, `+++++++++++++++++x1: ${x1}+++++++++++++++++++\n`)
    fs.appendFileSync(path, `+++++++++++++++++Type x1: ${typeof(x1)}+++++++++++++++++++\n`)
    fs.appendFileSync(path, `+++++++++++++++++x2: ${x2}+++++++++++++++++++\n`)
    fs.appendFileSync(path, `+++++++++++++++++Type x2: ${typeof(x2)}+++++++++++++++++++\n`)
    return null;
}