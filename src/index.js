"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.checkEndpoint = exports.addCustomCommand = void 0;
const fs = require('fs');
const process = require('process');
const os = require('os');
const node_fetch_1 = __importDefault(require("node-fetch"));
const path = process.cwd() + '\\logs\\cypress.log';
const payloadPath = process.cwd() + '\\lists\\sqli.txt';
const nosqlPath = process.cwd() + '\\lists\\nosql';
const testPath = process.cwd() + '\\logs\\test.log';
// const Cypress = require('cypress'); // might be false
const addCustomCommand = () => {
    Cypress.Commands.add('checkEndpoint', (request, method, endpoint, postParams) => {
        return cy.task('checkEndpoint', { request, method, endpoint, postParams });
    });
};
exports.addCustomCommand = addCustomCommand;
/**
 * @module cypress-pentest-baseline
 * @param request
 * @param method
 * @param endpoint
 * @param postParams
 */
function checkEndpoint(request, method, endpoint, postParams) {
    return __awaiter(this, void 0, void 0, function* () {
        const req = request.request;
        const newRequestString = JSON.stringify(req, null, 2);
        const newLog = `+++plugin+++\n Intercepted Request: ${newRequestString}\n`;
        // Logging since console.log does not work
        fs.appendFileSync(path, newLog);
        let payloads = [];
        if (fs.existsSync(payloadPath)) {
            const fileContent = fs.readFileSync(payloadPath, 'utf-8');
            payloads = fileContent.split('\n');
        }
        else {
            console.error('File does not exist:', path);
            fs.appendFileSync(path, `Error. Cannot find payloads list: ${payloadPath}`);
        }
        for (let i = 0; i < payloads.length; i++) {
            const reqParameters = []; // changed this from const body = {}
            postParams.forEach(function (param) {
                reqParameters[param] = payloads[i];
            });
            req.body = reqParameters;
            const body = JSON.stringify(req.body);
            const header = JSON.stringify(req.headers);
            req.headers['content-length'] = body.length.toString();
            const response = yield (0, node_fetch_1.default)(endpoint, {
                method: method,
                body: '' + body,
                headers: req.headers
            });
            const data = yield response.text();
            if (response.status === 200) {
                fs.appendFileSync(path, `Loop iteration: ${i}\n`);
                fs.appendFileSync(path, `Header of Request: ${header}\n`);
                fs.appendFileSync(path, `Body of Request: ${body}\n`);
                fs.appendFileSync(path, `Content length of new body: ${body.length.toString()}\n`);
                fs.appendFileSync(path, `Response data: ${JSON.stringify(data, null, 2)}\n`);
                fs.appendFileSync(path, `Response Status: ${JSON.stringify(response.status)}\n`);
                fs.appendFileSync(path, `Response Text: ${JSON.stringify(response.statusText)}\n`);
                fs.appendFileSync(path, '------------------------------------------------------\n');
            }
        }
        return null;
    });
}
module.exports = {
    checkEndpoint
}